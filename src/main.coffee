
'use strict'



#===========================================================================================================
GUY                       = require 'guy'
{ debug
  info
  warn
  urge
  help }                  = GUY.trm.get_loggers 'INTERVOKE'
{ rpr }                   = GUY.trm
{ get_base_types }        = require './types'
E                         = require './errors'
{ Phrase_parser }         = require './phrase-parser'


#===========================================================================================================
@Prompter = class Prompter

  #---------------------------------------------------------------------------------------------------------
  clasz = @

  #---------------------------------------------------------------------------------------------------------
  @create_proxy: ( x ) -> new Proxy x,
    get: ( target, accessor, receiver ) ->
      ### Return handler for given `accessor`. If instance doesn't have property `accessor` and instance has
      `__get_handler()`, call that method with `accessor`, set property `accessor` and return handler. In
      case instance has `__parser`, get `ast` as` `__parser.parse accessor` and call `__get_handler()` with
      `ast` as second argument. `__get_handler()` will only be called if `accessor` is a string that does
      not start with an underscore. ###
      return target[ accessor ] if Reflect.has target, accessor
      return target[ accessor ] if ( typeof accessor ) isnt 'string'
      return target[ accessor ] if accessor.startsWith '_'
      if Reflect.has target, '__get_handler'
        ast = if ( Reflect.has target, '__parser' ) then target.__parser.parse accessor else null
        return ( target[ accessor ] = R ) if ( R = target.__get_handler accessor, ast )?
      throw new E.Unknown_accessor '^Prompter/proxy.get@1^', accessor

  #---------------------------------------------------------------------------------------------------------
  constructor: ->
    return clasz.create_proxy @


#===========================================================================================================
@Intervoke = class Intervoke extends Prompter

  #---------------------------------------------------------------------------------------------------------
  clasz = @

  #---------------------------------------------------------------------------------------------------------
  constructor: ( cfg ) ->
    super()
    GUY.props.hide @, '__types',      get_base_types()
    GUY.props.hide @, '__cfg',        @__types.create.word_prompter_cfg cfg
    GUY.props.hide @, '__accessors',  new Set()
    @__absorb_declarations()
    return undefined

  #---------------------------------------------------------------------------------------------------------
  __walk_prototype_chain: ->
    R = []
    for object in ( GUY.props.get_prototype_chain @constructor ).reverse()
      yield object if @__types.is_extension_of object, clasz
    yield @
    return null

  #---------------------------------------------------------------------------------------------------------
  __nameit: ( name, f ) -> Object.defineProperty f, 'name', { value: name, }; f

  #---------------------------------------------------------------------------------------------------------
  __absorb_declarations: ->
    for object from @__walk_prototype_chain()
      continue unless Reflect.has object, 'declare'
      @__declare accessor, handler for accessor, handler of object.declare
    return null

  #---------------------------------------------------------------------------------------------------------
  __declare: ( accessor, handler ) ->
    ### Associate an accessor with a handler method: ###
    throw new E.Not_allowed_to_redeclare '^Intervoke::__declare@1^', accessor if Reflect.has @, accessor
    @__accessors.add accessor
    @__nameit accessor, handler
    GUY.props.hide @, accessor, handler
    return null


#===========================================================================================================
@Phrase_prompter = class Phrase_prompter extends Intervoke

  #---------------------------------------------------------------------------------------------------------
  constructor: ( cfg = null ) ->
    super cfg
    GUY.props.hide @, '__parser', new Phrase_parser()
    return undefined

  #---------------------------------------------------------------------------------------------------------
  __declare: ( accessor, handler ) ->
    debug '^Phrase_prompter::__declare@1^', { accessor, handler, }
    super accessor, handler
    return null

  #---------------------------------------------------------------------------------------------------------
  __get_handler: ( accessor, ast ) ->
    ### Given a accessor, returns a method to use for that accessor, either from cache a newly generated by
    calling `__create_handler()` which must be declared in derived classes. When used with alternative
    accessors, care has been taken to only call `__create_handler()` once and to cache alternative accessors
    along with the normalized one. ###
    # ast = @__parser.parse accessor
    debug '^Phrase_prompter::__get_handler@1^', { accessor, ast, }
    throw new Error "__get_handler() under construction"
    return R unless ( R = @[ accessor ] ) is undefined ### NOTE repeat from proxy ###
    #.......................................................................................................
    [ ncc, phrase  ] = @__get_ncc_and_phrase accessor
    unless ( R = @[ ncc ] ) is undefined
      GUY.props.hide @, accessor, R
      return R
    #.......................................................................................................
    R = @__nameit ncc, @__create_handler phrase
    @__declare ncc,      R
    @__declare accessor, R if accessor isnt ncc
    return R

  #---------------------------------------------------------------------------------------------------------
  __create_handler: ( accessor ) ->
    throw new E.Not_allowed_to_use_undeclared '^Phrase_prompter::__create_handler^', @, accessor

