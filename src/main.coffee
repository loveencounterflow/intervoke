
'use strict'



#===========================================================================================================
GUY                       = require 'guy'
{ debug
  info
  warn
  urge
  help }                  = GUY.trm.get_loggers 'INTERVOKE'
{ rpr }                   = GUY.trm


#-----------------------------------------------------------------------------------------------------------
### TAINT move this to Guy ###
class Guy_error_base_class extends Error
  constructor: ( ref, message ) ->
    super()
    if ref is null
      @message  = message
      return undefined
    @message  = "#{ref} (#{@constructor.name}) #{message}"
    @ref      = ref
    return undefined ### always return `undefined` from constructor ###

#-----------------------------------------------------------------------------------------------------------
class Wrong_use_of_abstract_base_class_method extends Guy_error_base_class
  constructor: ( ref, instance, method_name )     ->
    class_name = instance.constructor.name
    super ref, "not allowed to call method #{rpr method_name} of abstract base class #{rpr class_name}"


#===========================================================================================================
class Attributor extends Function

  #---------------------------------------------------------------------------------------------------------
  clasz = @

  #---------------------------------------------------------------------------------------------------------
  @create_proxy: ( x ) -> new Proxy x,
    get: ( target, accessor, receiver ) ->
      # info '^98-1^', rpr accessor
      return target[ accessor ] if ( typeof accessor ) is 'symbol'
      return target[ accessor ] if accessor is 'constructor'
      return target[ accessor ] if accessor.startsWith? and accessor.startsWith '__'
      return ( P... ) -> target accessor, P...

  #---------------------------------------------------------------------------------------------------------
  constructor: ->
    ### Trick to make this work; these are strings containing JS code: ###
    super '...P', 'return this.__me.__do(...P)'
    @__me = @bind @
    return clasz.create_proxy @__me

  #---------------------------------------------------------------------------------------------------------
  __do: ( P... ) ->
    ### Attributor instances are functions, and the `__do()` method is the code that they execute when being
    called. This method should be overridden in derived classes. ###
    throw new Wrong_use_of_abstract_base_class_method '^Attributor.__do^', @, '__do'


#===========================================================================================================
class Analyzing_attributor extends Attributor

  #---------------------------------------------------------------------------------------------------------
  @__cache: null

  #---------------------------------------------------------------------------------------------------------
  constructor: ->
    super()
    clasz     = @constructor
    @__cache  = if clasz.__cache? then ( new Map clasz.__cache ) else new Map()
    return undefined

  #---------------------------------------------------------------------------------------------------------
  __do: ( accessor, details... ) -> ( @__get_handler accessor ) details...

  #---------------------------------------------------------------------------------------------------------
  __get_handler: ( accessor ) ->
    ### Given a accessor, returns a method to use for that accessor, either from cache a newly generated by
    calling `__create_handler()` which must be declared in derived classes. When used with alternative
    accessors, care has been taken to only call `__create_handler()` once and to cache alternative accessors
    along with the normalized one. ###
    return @__cache.get accessor if @__cache.has accessor
    [ ncc, phrase  ] = @__get_ncc_and_phrase accessor
    #.......................................................................................................
    if @__cache.has ncc
      R = @__cache.get ncc
    #.......................................................................................................
    else
      R = @__nameit ncc, @__create_handler
      @__cache.set ncc,       R
    #.......................................................................................................
    @__cache.set accessor,  R
    return R

  #---------------------------------------------------------------------------------------------------------
  __create_handler: ( phrase ) ->
    ### Given a phrase (the parts of an accessor when split), return a function that takes details as
    arguments and returns a resolution. ###
    throw new Wrong_use_of_abstract_base_class_method '^Analyzing_attributor.__create_handler^', @, '__create_handler'

  #---------------------------------------------------------------------------------------------------------
  __get_ncc_and_phrase: ( accessor ) ->
    ### Given an accessor (string), return a phrase (list of strings): ###
    phrase  = accessor.split /[\s_]+/u
    ncc     = phrase.join '_'
    return [ ncc, phrase, ]

  #---------------------------------------------------------------------------------------------------------
  __declare: ( accessor, handler ) ->
    ### Associate an accessor with a handler method: ###
    ### TAINT check for overwrites ###
    @__cache.set accessor, handler
    return null

  #---------------------------------------------------------------------------------------------------------
  __nameit: ( name, f ) -> Object.defineProperty f, 'name', { value: name, }; f



