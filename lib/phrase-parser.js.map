{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/phrase-parser.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n\n#===========================================================================================================\nGUY                       = require 'guy'\n{ debug\n  info\n  warn\n  urge\n  help }                  = GUY.trm.get_loggers 'INTERVOKE/PROMPT-PARSER'\n{ rpr }                   = GUY.trm\n{ get_base_types }        = require './types'\nE                         = require './errors'\n\n\n\n#===========================================================================================================\nvocabulary  =\n  of:       { role: 'of',         }\n  or:       { role: 'or',         }\n  optional: { role: 'optional',   }\n  #.......................................................................................................\n  empty:    { role: 'adjective',  }\n  nonempty: { role: 'adjective',  }\n  positive: { role: 'adjective',  }\n  negative: { role: 'adjective',  }\n  #.......................................................................................................\n  set:      { role: 'noun', adjectives: [ 'empty', 'nonempty',      ], }\n  text:     { role: 'noun', adjectives: [ 'empty', 'nonempty',      ], }\n  list:     { role: 'noun', adjectives: [ 'empty', 'nonempty',      ], }\n  integer:  { role: 'noun', adjectives: [ 'positive', 'negative',   ], }\n\n\n#===========================================================================================================\n@Phrase_parser = class Phrase_parser\n\n  #---------------------------------------------------------------------------------------------------------\n  parse: ( sentence ) ->\n    words           = sentence.split '_'\n    alternatives    = []\n    R               = { alternatives, optional: false, }\n    has_container   = false\n    #.......................................................................................................\n    for disjunct from @_walk_disjuncts words\n      depth = -1\n      for element_clause from @_walk_element_clauses disjunct\n        depth++\n        #...................................................................................................\n        { phrase }    = element_clause\n        if phrase.length is 0\n          throw new E.Empty_alternative_clause '^Phrase_parser.parse@1^', sentence\n        noun          = phrase.at -1\n        noun_entry    = @_get_vocabulary_entry phrase, noun, 'noun'\n        #...................................................................................................\n        alternative             = { noun, }\n        adjectives              = @_get_adjectives R, phrase\n        alternative.adjectives  = adjectives if adjectives.length > 0\n        if element_clause.elements?\n          if element_clause.elements.elements?\n            throw new E.Nested_containers '^Phrase_parser.parse@2^', sentence\n          has_container                   = true\n          { phrase: lphrase }             = element_clause.elements\n          ladjectives                     = @_get_adjectives R, lphrase\n          alternative.elements            = { noun: ( lphrase.at -1 ), }\n          alternative.elements.adjectives = ladjectives if ladjectives.length > 0\n        alternatives.push alternative if depth is 0\n    #.......................................................................................................\n    if has_container and R.alternatives.length > 1\n      throw new E.Container_with_alternatives '^Phrase_parser.parse@3^', sentence\n    # help '^Phrase_parser.parse@2^', rpr sentence\n    # debug '^Phrase_parser.parse@2^', { has_container, }, R.alternatives.length\n    #.......................................................................................................\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _$walk_disjuncts: ( declaration ) ->\n    ### assuming no empty strings ###\n    disjunct_lst = []\n    for word in declaration\n      if word is 'or'\n        yield disjunct_lst\n        disjunct_lst = []\n        continue\n      disjunct_lst.push word\n    yield disjunct_lst\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_disjuncts: ( words ) ->\n    for disjunct_lst from @_$walk_disjuncts words\n      if disjunct_lst.length is 0\n        declaration = words.join ' '\n        throw new E.Empty_alternative_clause '^Phrase_parser._walk_disjuncts@1^', declaration\n      yield disjunct_lst\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_vocabulary_entry: ( phrase, word, role = null ) ->\n    unless ( R = vocabulary[ word ] )?\n      phrase_txt = phrase.join '_'\n      throw new E.Undeclared_word '^Phrase_parser._get_vocabulary_entry@1^', phrase_txt, word\n    if role? and R.role isnt role\n      phrase_txt = phrase.join '_'\n      throw new E.Wrong_role '^Phrase_parser._get_vocabulary_entry@1^', phrase_txt, word, role, R.role\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_adjectives: ( ast, phrase ) ->\n    R = []\n    for adjective, idx in phrase\n      break if idx >= phrase.length - 1\n      if adjective is 'optional'\n        unless idx is 0\n          phrase_txt = phrase.join '_'\n          throw new E.Optional_not_first '^Phrase_parser._get_adjectives@1', phrase_txt\n        ast.optional = true\n        continue\n      @_get_vocabulary_entry phrase, adjective, 'adjective'\n      R.push adjective\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _find_element_clauses: ( words ) ->\n    R = { phrase: [], }\n    for word, idx in words\n      if word is 'or'\n        clause = words.join '_'\n        throw new E.Not_allowed_to_use_or_in_element_clause '^Phrase_parser._find_element_clauses^', clause\n      if word is 'of'\n        R.elements = @_find_element_clauses words[ idx + 1 .. ]\n        return R\n      R.phrase.push word\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_element_clauses: ( words ) ->\n    clause = @_find_element_clauses words\n    yield from @_$walk_element_clauses clause\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _$walk_element_clauses: ( clause ) ->\n    yield clause\n    yield from @_$walk_element_clauses clause.elements if clause.elements?\n    return null\n\n  # #---------------------------------------------------------------------------------------------------------\n  # #.........................................................................................................\n  ### NOTE likely not to be used: ###\n  # T?.eq ( pp._find_all [ 'nonempty', 'list', 'of', 'list', 'of', 'text', ], 'of'        ), [ 2, 4 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'b'                                     ), [ 1 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'd'                                     ), [ 3 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'e'                                     ), []\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', 'c', ], 'c'                                ), [ 2, 4 ]\n  # _find_all: ( list, value ) ->\n  #   ### TAINT comments to https://stackoverflow.com/a/20798567/7568091 suggest for-loop may be faster ###\n  #   R   = []\n  #   idx = -1\n  #   R.push idx while ( idx = list.indexOf value, idx + 1 ) > -1\n  #   return R\n\n\n"
  ]
}