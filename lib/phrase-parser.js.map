{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/phrase-parser.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n\n#===========================================================================================================\nGUY                       = require 'guy'\n{ debug\n  info\n  warn\n  urge\n  help }                  = GUY.trm.get_loggers 'INTERVOKE/PROMPT-PARSER'\n{ rpr }                   = GUY.trm\n{ get_base_types }        = require './types'\nE                         = require './errors'\n\n\n\n#===========================================================================================================\nvocabulary  =\n  of:       { role: 'of',         }\n  or:       { role: 'or',         }\n  optional: { role: 'optional',   }\n  #.......................................................................................................\n  empty:    { role: 'adjective',  }\n  nonempty: { role: 'adjective',  }\n  positive: { role: 'adjective',  }\n  negative: { role: 'adjective',  }\n  #.......................................................................................................\n  text:     { role: 'noun', adjectives: [ 'empty', 'nonempty',      ], }\n  list:     { role: 'noun', adjectives: [ 'empty', 'nonempty',      ], }\n  integer:  { role: 'noun', adjectives: [ 'positive', 'negative',   ], }\n\n\n#===========================================================================================================\n@Phrase_parser = class Phrase_parser\n\n  #---------------------------------------------------------------------------------------------------------\n  parse: ( sentence ) ->\n    words           = sentence.split '_'\n    alternatives    = []\n    R               = { alternatives, optional: false, }\n    for disjunct from @_walk_disjuncts words\n      depth = -1\n      for element_clause from @_walk_element_clauses disjunct\n        depth++\n        #...................................................................................................\n        { phrase }    = element_clause\n        throw new E.Empty_alternative_phrase '^Phrase_parser.parse^', sentence if phrase.length is 0\n        noun          = phrase.at -1\n        noun_entry    = @_get_vocabulary_entry phrase, noun, 'noun'\n        #...................................................................................................\n        ### NOTE not entirely correct, must look for 'of' ###\n        alternative             = { noun, }\n        adjectives              = @_get_adjectives R, phrase\n        alternative.adjectives  = adjectives if adjectives.length > 0\n        if element_clause.elements?\n          ### TAINT throw error if alternative.elements has elements ###\n          { phrase: lphrase }             = element_clause.elements\n          ladjectives                     = @_get_adjectives R, lphrase\n          alternative.elements            = { noun: ( lphrase.at -1 ), }\n          alternative.elements.adjectives = ladjectives if ladjectives.length > 0\n        alternatives.push alternative if depth is 0\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _$walk_disjuncts: ( declaration ) ->\n    ### assuming no empty strings ###\n    disjunct_lst = []\n    for word in declaration\n      if word is 'or'\n        yield disjunct_lst\n        disjunct_lst = []\n        continue\n      disjunct_lst.push word\n    yield disjunct_lst\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_disjuncts: ( words ) ->\n    for disjunct_lst from @_$walk_disjuncts words\n      if disjunct_lst.length is 0\n        declaration = words.join ' '\n        throw new Error \"empty alternative clause in declaration #{rpr declaration}\"\n      yield disjunct_lst\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_vocabulary_entry: ( phrase, word, role = null ) ->\n    unless ( R = vocabulary[ word ] )?\n      phrase_txt = phrase.join '_'\n      throw new Error \"word #{rpr word} in phrase #{rpr phrase_txt} is unknown\"\n    if role? and R.role isnt role\n      phrase_txt = phrase.join '_'\n      throw new Error \"expected word #{rpr word} in phrase #{rpr phrase_txt} to have role #{rpr role} but is declared to be #{rpr R.role}\"\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_adjectives: ( ast, phrase ) ->\n    R = []\n    for adjective, idx in phrase\n      break if idx >= phrase.length - 1\n      if adjective is 'optional'\n        unless idx is 0\n          phrase_txt = phrase.join '_'\n          throw new Error \"expected 'optional' to occur as first word in phrase, got #{rpr phrase_txt}\"\n        ast.optional = true\n        continue\n      @_get_vocabulary_entry phrase, adjective, 'adjective'\n      R.push adjective\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _find_element_clauses: ( words ) ->\n    R = { phrase: [], }\n    for word, idx in words\n      if word is 'or'\n        clause = words.join '_'\n        throw new E.Not_allowed_to_use_or_in_element_clause '^Phrase_parser._find_element_clauses^', clause\n      if word is 'of'\n        R.elements = @_find_element_clauses words[ idx + 1 .. ]\n        return R\n      R.phrase.push word\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_element_clauses: ( words ) ->\n    clause = @_find_element_clauses words\n    yield from @_$walk_element_clauses clause\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _$walk_element_clauses: ( clause ) ->\n    yield clause\n    yield from @_$walk_element_clauses clause.elements if clause.elements?\n    return null\n\n  # #---------------------------------------------------------------------------------------------------------\n  # #.........................................................................................................\n  ### NOTE likely not to be used: ###\n  # T?.eq ( pp._find_all [ 'nonempty', 'list', 'of', 'list', 'of', 'text', ], 'of'        ), [ 2, 4 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'b'                                     ), [ 1 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'd'                                     ), [ 3 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'e'                                     ), []\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', 'c', ], 'c'                                ), [ 2, 4 ]\n  # _find_all: ( list, value ) ->\n  #   ### TAINT comments to https://stackoverflow.com/a/20798567/7568091 suggest for-loop may be faster ###\n  #   R   = []\n  #   idx = -1\n  #   R.push idx while ( idx = list.indexOf value, idx + 1 ) > -1\n  #   return R\n\n\n"
  ]
}