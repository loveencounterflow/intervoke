{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/phrase-parser.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n\n#===========================================================================================================\nGUY                       = require 'guy'\n{ debug\n  info\n  warn\n  urge\n  help }                  = GUY.trm.get_loggers 'INTERVOKE/PROMPT-PARSER'\n{ rpr }                   = GUY.trm\n{ get_base_types }        = require './types'\nE                         = require './errors'\n\n\n\n#===========================================================================================================\nvocabulary  =\n  of:       { role: 'of',         }\n  or:       { role: 'or',         }\n  optional: { role: 'optional',   }\n  #.......................................................................................................\n  empty:    { role: 'adjective',  }\n  nonempty: { role: 'adjective',  }\n  positive: { role: 'adjective',  }\n  negative: { role: 'adjective',  }\n  #.......................................................................................................\n  text:     { role: 'noun', adjectives: [ 'empty', 'nonempty',      ], }\n  list:     { role: 'noun', adjectives: [ 'empty', 'nonempty',      ], }\n  integer:  { role: 'noun', adjectives: [ 'positive', 'negative',   ], }\n\n\n#===========================================================================================================\n@Phrase_parser = class Phrase_parser\n\n  #---------------------------------------------------------------------------------------------------------\n  parse: ( sentence ) ->\n    words           = sentence.split '_'\n    # debug '^99-1^', element_clauses\n    alternatives    = []\n    R               = { alternatives, optional: false, }\n    for phrase from @_walk_alternative_phrases words\n      depth = -1\n      for element_clause from @_walk_element_clauses phrase\n        depth++\n        debug '^4534^', sentence, ( GUY.trm.green depth ), GUY.trm.gold element_clause\n        # unless depth is 0\n        #...................................................................................................\n        { phrase }    = element_clause\n        throw new E.Empty_alternative_phrase '^Phrase_parser.parse^', sentence if phrase.length is 0\n        noun          = phrase.at -1\n        noun_entry    = @_get_vocabulary_entry phrase, noun, 'noun'\n        #...................................................................................................\n        ### NOTE not entirely correct, must look for 'of' ###\n        alternative             = { noun, }\n        adjectives              = @_get_adjectives R, phrase\n        urge '^3324^', GUY.trm.green alternative, element_clause\n        alternative.adjectives  = adjectives if adjectives.length > 0\n        alternative.elements    = element_clause.elements if element_clause.elements?\n        alternatives.push alternative if depth is 0\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _$walk_alternative_phrases: ( sentence ) ->\n    ### assuming no empty strings ###\n    phrase    = []\n    for word in sentence\n      if word is 'or'\n        yield phrase\n        phrase = []\n        continue\n      phrase.push word\n    yield phrase\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_alternative_phrases: ( words ) ->\n    for phrase from @_$walk_alternative_phrases words\n      sentence = words.join ' '\n      throw new Error \"empty alternative clause in sentence #{rpr sentence}\" if phrase.length is 0\n      yield phrase\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_vocabulary_entry: ( phrase, word, role = null ) ->\n    unless ( R = vocabulary[ word ] )?\n      phrase_txt = phrase.join '_'\n      throw new Error \"word #{rpr word} in phrase #{rpr phrase_txt} is unknown\"\n    if role? and R.role isnt role\n      phrase_txt = phrase.join '_'\n      throw new Error \"expected word #{rpr word} in phrase #{rpr phrase_txt} to have role #{rpr role} but is declared to be #{rpr R.role}\"\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_adjectives: ( ast, phrase ) ->\n    R = []\n    for adjective, idx in phrase\n      break if idx >= phrase.length - 1\n      if adjective is 'optional'\n        unless idx is 0\n          phrase_txt = phrase.join '_'\n          throw new Error \"expected 'optional' to occur as first word in phrase, got #{rpr phrase_txt}\"\n        ast.optional = true\n        continue\n      @_get_vocabulary_entry phrase, adjective, 'adjective'\n      R.push adjective\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _find_element_clauses: ( words ) ->\n    R = { phrase: [], }\n    for word, idx in words\n      if word is 'or'\n        clause = words.join '_'\n        throw new E.Not_allowed_to_use_or_in_element_clause '^Phrase_parser._find_element_clauses^', clause\n      if word is 'of'\n        R.elements = @_find_element_clauses words[ idx + 1 .. ]\n        return R\n      R.phrase.push word\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_element_clauses: ( words ) ->\n    clause = @_find_element_clauses words\n    yield from @_$walk_element_clauses clause\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _$walk_element_clauses: ( clause ) ->\n    yield clause\n    yield from @_$walk_element_clauses clause.elements if clause.elements?\n    return null\n\n  # #---------------------------------------------------------------------------------------------------------\n  # #.........................................................................................................\n  ### NOTE likely not to be used: ###\n  # T?.eq ( pp._find_all [ 'nonempty', 'list', 'of', 'list', 'of', 'text', ], 'of'        ), [ 2, 4 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'b'                                     ), [ 1 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'd'                                     ), [ 3 ]\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', ], 'e'                                     ), []\n  # T?.eq ( pp._find_all [ 'a', 'b', 'c', 'd', 'c', ], 'c'                                ), [ 2, 4 ]\n  # _find_all: ( list, value ) ->\n  #   ### TAINT comments to https://stackoverflow.com/a/20798567/7568091 suggest for-loop may be faster ###\n  #   R   = []\n  #   idx = -1\n  #   R.push idx while ( idx = list.indexOf value, idx + 1 ) > -1\n  #   return R\n\n\n"
  ]
}