(function() {
  'use strict';
  var GUY, Guy_error_base_class, Phrasal_prompter, Prompter, Word_prompter, Wrong_use_of_abstract_base_class_method, debug, get_base_types, help, info, rpr, urge, warn;

  //===========================================================================================================
  GUY = require('guy');

  ({debug, info, warn, urge, help} = GUY.trm.get_loggers('INTERVOKE'));

  ({rpr} = GUY.trm);

  ({get_base_types} = require('./types'));

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT move this to Guy */
  Guy_error_base_class = class Guy_error_base_class extends Error {
    constructor(ref, message) {
      super();
      if (ref === null) {
        this.message = message;
        return void 0;
      }
      this.message = `${ref} (${this.constructor.name}) ${message}`;
      this.ref = ref;
      return void 0/* always return `undefined` from constructor */;
    }

  };

  //-----------------------------------------------------------------------------------------------------------
  Wrong_use_of_abstract_base_class_method = class Wrong_use_of_abstract_base_class_method extends Guy_error_base_class {
    constructor(ref, instance, method_name) {
      var class_name;
      class_name = instance.constructor.name;
      super(ref, `not allowed to call method ${rpr(method_name)} of abstract base class ${rpr(class_name)}`);
    }

  };

  //===========================================================================================================
  this.Prompter = Prompter = (function() {
    var clasz;

    class Prompter extends Function {
      //---------------------------------------------------------------------------------------------------------
      static create_proxy(x) {
        return new Proxy(x, {
          get: function(target, accessor, receiver) {
            var R;
            if ((R = target[accessor]) !== void 0) {
              return R;
            }
            if ((typeof accessor) !== 'string') {
              return target[accessor];
            }
            if (accessor.startsWith('_')) {
              return target[accessor];
            }
            return function(...P) {
              return target(accessor, ...P);
            };
          }
        });
      }

      //---------------------------------------------------------------------------------------------------------
      constructor() {
        /* Trick to make this work; these are strings containing JS code: */
        super('...P', 'return this.__me.__do(...P)');
        this.__me = this.bind(this);
        return clasz.create_proxy(this.__me);
      }

      //---------------------------------------------------------------------------------------------------------
      __do(...P) {
        /* Prompter instances are functions, and the `__do()` method is the code that they execute when being
           called. This method should be overridden in derived classes. */
        throw new Wrong_use_of_abstract_base_class_method('^Prompter.__do^', this, '__do');
      }

    };

    //---------------------------------------------------------------------------------------------------------
    clasz = Prompter;

    return Prompter;

  }).call(this);

  //===========================================================================================================
  this.Word_prompter = Word_prompter = class Word_prompter extends Prompter {
    //---------------------------------------------------------------------------------------------------------
    constructor(cfg) {
      super();
      GUY.props.hide(this, '__types', get_base_types());
      this.__cfg = this.__types.create.word_prompter_cfg(cfg);
      return void 0;
    }

    //---------------------------------------------------------------------------------------------------------
    __do(accessor, ...details) {
      return (this.__get_handler(accessor))(...details);
    }

    //---------------------------------------------------------------------------------------------------------
    __get_handler(accessor) {
      var R, ncc, phrase;
      if ((R = this[accessor]) !== void 0/* NOTE repeat from proxy */) {
        /* Given a accessor, returns a method to use for that accessor, either from cache a newly generated by
           calling `__create_handler()` which must be declared in derived classes. When used with alternative
           accessors, care has been taken to only call `__create_handler()` once and to cache alternative accessors
           along with the normalized one. */
        return R;
      }
      //.......................................................................................................
      [ncc, phrase] = this.__get_ncc_and_phrase(accessor);
      if ((R = this[ncc]) !== void 0) {
        GUY.props.hide(this, accessor, R);
        return R;
      }
      //.......................................................................................................
      R = this.__nameit(ncc, this.__create_handler(phrase));
      this.__declare(ncc, R);
      if (accessor !== ncc) {
        this.__declare(accessor, R);
      }
      return R;
    }

    //---------------------------------------------------------------------------------------------------------
    __create_handler(phrase) {
      /* Given a phrase (the parts of an accessor when split), return a function that takes details as
         arguments and returns a resolution. */
      throw new Wrong_use_of_abstract_base_class_method('^Word_prompter.__create_handler^', this, '__create_handler');
    }

    //---------------------------------------------------------------------------------------------------------
    __get_ncc_and_phrase(accessor) {
      /* Given an accessor (string), return a phrase (list of strings): */
      var ncc, phrase;
      phrase = accessor.split(/[\s_]+/u);
      ncc = phrase.join('_');
      return [ncc, phrase];
    }

    //---------------------------------------------------------------------------------------------------------
    __declare(accessor, handler) {
      /* Associate an accessor with a handler method: */
      /* TAINT check for overwrites */
      GUY.props.hide(this, accessor, handler);
      return null;
    }

    //---------------------------------------------------------------------------------------------------------
    __nameit(name, f) {
      Object.defineProperty(f, 'name', {
        value: name
      });
      return f;
    }

  };

  //===========================================================================================================
  this.Phrasal_prompter = Phrasal_prompter = class Phrasal_prompter extends Word_prompter {
    //---------------------------------------------------------------------------------------------------------
    __declare(accessor, handler) {
      return debug('^54-1^', {accessor, handler});
    }

  };

}).call(this);

//# sourceMappingURL=main.js.map